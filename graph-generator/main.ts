import { readFileSync, writeFileSync } from 'fs';
import Graph from 'graphology';
import forceAtlas2 from 'graphology-layout-forceatlas2';
import { Dataset, NodeData } from 'types';
import { loadTree, TreeCommandDirectoryNode } from 'src/tree';
import { loadClusters, clusterForNodeName } from 'src/cluster';


/*
 * Clusters match on string startswith with the path
 * Clusters paths must be more specific later in the list so that the "last one wins".
 */
const clusters = loadClusters('clusters.json');

/**
 *  1. Generate the Graphology Graph
 */

const interimGraph = new Graph();

function addDirectoryToGraph(parentDirectoryNode: TreeCommandDirectoryNode) {
    parentDirectoryNode.contents.map((childNode) => {
        if (childNode.type === 'file') {
            interimGraph.addNode(childNode.name, {
                label: childNode.name,
                key: childNode.name,
                tag: 'List',
                URL: '',
                cluster: clusterForNodeName(childNode.name, clusters),
                score: interimGraph.getNodeAttribute(parentDirectoryNode.name, 'score') - 0.1,
                fileType: 'file',
            });
            interimGraph.addEdge(parentDirectoryNode.name, childNode.name);
        }

        if (childNode.type === 'directory') {
            interimGraph.addNode(childNode.name, {
                label: childNode.name,
                key: childNode.name,
                fileType: 'directory',
                tag: 'List',
                URL: '',
                cluster: clusterForNodeName(childNode.name, clusters),
                score: interimGraph.getNodeAttribute(parentDirectoryNode.name, 'score') - 0.1,
            });
            interimGraph.addEdge(parentDirectoryNode.name, childNode.name);

            addDirectoryToGraph(childNode);
        }
    });
}

// add the root node as generated by tree -fJ
interimGraph.addNode('.', {
    label: '.',
    key: '.',
    fileType: 'directory',
    tag: 'List',
    URL: '',
    cluster: 0,
    score: 10,
});

const inputTree = loadTree('tree.json');

addDirectoryToGraph(inputTree[0]);

interimGraph.nodes().forEach((node, i) => {
    const angle = (i * 2 * Math.PI) / interimGraph.order;
    interimGraph.setNodeAttribute(node, 'x', 100 * Math.cos(angle));
    interimGraph.setNodeAttribute(node, 'y', 100 * Math.sin(angle));

    let nodeFileType = interimGraph.getNodeAttribute(node, 'fileType');

    if (nodeFileType == 'file') {
        interimGraph.setNodeAttribute(node, 'color', 'red');
    } else {
        interimGraph.setNodeAttribute(node, 'color', 'blue');
    }
});

forceAtlas2.assign(interimGraph, 50);

/*
 *  2. Re-write Graphology graph JSON to the data structure we need to render.
 */

const serialisedGraphologyGraph = interimGraph.export();

let exportGraph: Dataset = {
    nodes: serialisedGraphologyGraph.nodes.map((node) => {
        return node.attributes as NodeData; // we generate the graph so know the type matches
    }),
    edges: serialisedGraphologyGraph.edges.map((edge) => {
        return [edge.source, edge.target];
    }),
    clusters: clusters,
    tags: [
        { key: 'Chart type', image: 'charttype.svg' },
        { key: 'Company', image: 'company.svg' },
        { key: 'Concept', image: 'concept.svg' },
        { key: 'Field', image: 'field.svg' },
        { key: 'List', image: 'list.svg' },
        { key: 'Method', image: 'method.svg' },
        { key: 'Organization', image: 'organization.svg' },
        { key: 'Person', image: 'person.svg' },
        { key: 'Technology', image: 'technology.svg' },
        { key: 'Tool', image: 'tool.svg' },
        { key: 'unknown', image: 'unknown.svg' },
    ],
};

writeFileSync('graph.json', JSON.stringify(exportGraph));
